---
title: API Reference
description: Detailed API documentation for SnapEngine's queue system and DOM utilities.
order: 3
sectionTitle: SnapEngine
sectionOrder: 1
---

## Queuing DOM Updates

The primary way to interact with the DOM in SnapEngine is through the `queueUpdate` method available on any `BaseObject` (or its subclasses like `ElementObject`).

**Signature:**

```typescript
object.queueUpdate(stage, callback, queueID?)
```

- **stage**: One of `"READ_1"`, `"WRITE_1"`, `"READ_2"`, `"WRITE_2"`, `"READ_3"`, `"WRITE_3"`.
- **callback**: The function to execute.
- **queueID**: (Optional) A unique ID. If you queue multiple updates with the same ID in the same frame, only the last one will execute.

**Example:**

```typescript
// BAD: Interleaved read/write causing layout thrashing
const width = element.offsetWidth; // Read
element.style.width = (width + 10) + 'px'; // Write
const newWidth = element.offsetWidth; // Read (Forces Layout)
element.style.height = (newWidth * 2) + 'px'; // Write

// GOOD: Using SnapEngine's queue system
object.queueUpdate("READ_1", () => {
    // Read current state
    const width = object.element.offsetWidth;
    
    // Schedule the write based on the read
    object.queueUpdate("WRITE_1", () => {
        object.element.style.width = (width + 10) + 'px';
        
        // Schedule next read if needed
        object.queueUpdate("READ_2", () => {
            const newWidth = object.element.offsetWidth;
            
            object.queueUpdate("WRITE_2", () => {
                object.element.style.height = (newWidth * 2) + 'px';
            });
        });
    });
});
```

## Best Practices

1. **Always use `queueUpdate` for DOM access**: Never read or write to the DOM directly inside your main logic loops or event handlers. Always schedule it.
2. **Group operations by stage**:
   - Use `READ_1` for gathering initial state (e.g., mouse position, current element size).
   - Use `WRITE_1` for the main visual updates (e.g., moving an element).
   - Use `READ_2` / `WRITE_2` only if your update depends on the result of `WRITE_1` (e.g. checking if an element wrapped after resizing, using FLIP technique for animations, etc.).
   - `READ_3` / `WRITE_3` should not be used unless absolutely neccesary.
3. **Use `queueID` for frequent events**: If you are queuing updates from a high-frequency event like `mousemove`, provide a `queueID` so that pending updates are debounced/overwritten, ensuring only the latest update runs per frame.
4. **Cache DOM properties**: Minimize direct DOM reads by using cached values from `getDomProperty()`. Call `readDom()` during a READ stage, then access the cached properties throughout your logic without triggering additional reflows.

```typescript
// Inside a mousemove handler
object.queueUpdate("WRITE_1", () => {
    this.updatePosition();
}, "update_pos_id"); // "update_pos_id" ensures we don't stack 100s of updates per frame
```

## DOM Property Caching

SnapEngine caches DOM properties to minimize expensive `getBoundingClientRect()` calls.

**How it works:**
- When you call `readDom()` inside a READ queue, the element's position and dimensions are read from the DOM and stored in an internal cache.
- The cache is keyed by render stage (`READ_1`, `READ_2`, `READ_3`), allowing you to track how properties change across stages (useful for FLIP animations).
- `getDomProperty(stage)` returns the cached values from the specified stage without triggering a DOM read.

**Example:**

```typescript
// ElementObject has built-in caching
object.queueUpdate("READ_1", () => {
    object.readDom(); // Reads DOM and caches to READ_1 slot
});

object.queueUpdate("WRITE_1", () => {
    // Apply some changes
    object.element.classList.add('expanded');
});

object.queueUpdate("READ_2", () => {
    object.readDom(); // Reads DOM and caches to READ_2 slot
    
    // Compare before/after (FLIP technique)
    const before = object.getDomProperty("READ_1");
    const after = object.getDomProperty("READ_2");
    
    const deltaX = before.x - after.x;
    const deltaY = before.y - after.y;
    
    // Use delta for animation inversion
});
```

**Cached Properties:**
- `x`, `y`: World coordinates
- `screenX`, `screenY`: Screen/viewport coordinates
- `width`, `height`: Dimensions in world space
- `scaleX`, `scaleY`: Scale factors

## ElementObject Convenience Methods

`ElementObject` (the base class for DOM-backed objects) provides higher-level methods that combine queuing with common read/write operations.

### Reading: `readDom()` and `requestRead()`

**`readDom(accountTransform?, stage?)`**
Immediately reads DOM properties and caches them. Should only be called inside a READ queue callback.

```typescript
object.queueUpdate("READ_1", () => {
    object.readDom();  // Reads and caches position/dimensions
});
```

**`requestRead(accountTransform?, saveTransform?, stage?)`**
Convenience method that queues `readDom()` to run in the specified stage. Returns a `queueEntry`.

```typescript
// These are roughly equivalent:
object.requestRead(false, true, "READ_1");

object.queueUpdate("READ_1", () => {
    object.readDom(false);
    object.saveDomPropertyToTransform("READ_1");
});
```

Parameters:
- `accountTransform`: If `true`, subtracts any CSS transform from the read values (useful for getting the "natural" position).
- `saveTransform`: If `true`, automatically copies the cached position to `object.transform`.
- `stage`: Which READ stage to queue in (`"READ_1"`, `"READ_2"`, `"READ_3"`).

### Writing: `writeDom()`, `writeTransform()`, and `requestWrite()`

**`writeDom()`**
Writes all pending style, class, and data attribute changes to the DOM element. Should only be called inside a WRITE queue callback.

```typescript
object.style = { backgroundColor: 'red', padding: '10px' };
object.classList = ['active', 'highlighted'];

object.queueUpdate("WRITE_1", () => {
    object.writeDom();  // Applies all pending changes
});
```

**`writeTransform()`**
Writes only the CSS `transform` property. This is more performant than `writeDom()` because transforms don't trigger layout recalculation.

```typescript
object.worldPosition = [100, 200];

object.queueUpdate("WRITE_1", () => {
    object.writeTransform();  // Only updates transform, no layout thrashing
});
```

**`requestWrite(mutate?, writeCallback?, stage?)`**
Convenience method that queues `writeDom()` to run in the specified stage.

```typescript
// Queue a write with custom callback
object.requestWrite(true, () => {
    console.log('Write complete!');
}, "WRITE_1");
```

**`requestTransform(stage?)`**
Convenience method that queues `writeTransform()` to run in the specified stage.

```typescript
object.worldPosition = [100, 200];
object.requestTransform("WRITE_1");  // Queues transform update
```

## Helper Utilities

SnapEngine provides several helper functions to make working with the DOM and coordinate systems easier.

### `getDomProperty(engine, element)`

Retrieves the position and dimensions of a DOM element in multiple coordinate spaces (World, Camera, Screen). This is essential because `getBoundingClientRect` only gives you screen coordinates, which change when the camera pans or zooms.

```typescript
import { getDomProperty } from 'SnapEngine';

// Inside a READ queue
const props = getDomProperty(engine, myElement);

console.log(props.x, props.y);           // World coordinates (consistent regardless of camera)
console.log(props.screenX, props.screenY); // Screen coordinates (relative to viewport)
console.log(props.width, props.height);    // World dimensions
```

### `setDomStyle(element, style)`

A helper to apply styles to an element.

```typescript
import { setDomStyle } from 'SnapEngine';

// Inside a WRITE queue
setDomStyle(element, {
    width: '100px',
    backgroundColor: 'red'
});
```
